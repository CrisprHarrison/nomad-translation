// Generic confirmation (Confirm? [yes/ok/delete, cancel])
confirm = "Bestätigen?";
// Answer to a question (Are you sure you want to do that? [yes, cancel])
confirm.yes = "Ja";
// The generic ok in a confirm box (The next operation is dangerous. [ok, cancel])
confirm.ok = "OK";
// Cancel something after being asked (Question? [answer, cancel])
confirm.cancel = "Abbrechen";

// Name of an item (object, tool, etc)
item.name = "Name";
// Rename an item (object, tool, etc)
item.rename = "Umbenennen";
// Add a new item (object, tool, project, etc)
item.add = "Hinzufügen";
// Save an item (object, tool, etc)
item.save = "Speichern";
item.save.confirm = "Speichern bestätigen?";
// Reload last save of an item (object, tool, etc)
item.lastSave = "Letzte Speicher";
// Reload last save of an item (object, tool, etc)
item.lastSave.confirm = "Letzte Speicherung laden?";
// Reset an item to its initial value (object, tool, etc)
item.reset = "Reset";
item.reset.confirm = "Zurücksetzen bestätigen?";
// Clone an item (object, tool, etc)
item.clone = "Klonen";
// Delete an item (object, tool, etc)
item.delete = "Löschen";
item.delete.confirm = "Löschen bestätigen?";
item.delete.confirm.yes = "JA, löschen";
// Item visibility (object, layer, etc)
item.visible = "";
// Show an item (object, layer, etc)
item.show = "";
// Hide an item (object, layer, etc)
item.hide = "";
// Select an item (object, layer, etc)
item.select = "";
// Unselect an item (object, layer, etc)
item.unselect = "";
// Merge an item with another one below (layer)
item.mergeDown = "Merge down";
// The order of an item in a list
item.order = "";

// Three-state toggle button (Auto, Off, On)
toggle.on = "";
// Three-state toggle button (Auto, Off, On)
toggle.off = "";
// Three-state toggle button (Auto, Off, On)
toggle.auto = "";

// Need at least to select one object
scene.noneButNeedAtLeastOne = "Kein Mesh ausgewählt";
// Need to select one object only
scene.noneButNeedOne = "";
// Need to select one object only
scene.onlyOneObject = "Mehrere Meshes sind ausgewählt, bitte nur ein Mesh auswählen."


// When you launch the app and we need to reprocess some resource thumbnails
loading.reprocess = "Fehlende Vorschaubilder, erstelle neu... ($0/$1)

$2";

// Dolor of an object
material.color = "Color";
// Defines how blurry or sharp the reflection on a material is
material.roughness = "Roughness";
// Whether the material is a metal or not
material.metalness = "Metalness";

// Minify
about.minify = "Menüs ausblenden";
about.minify.help = "Sie können auch mit 4 Fingern auf den Bildschirm tippen, wenn Ihr Gerät dies unterstützt.";
// Turntable will rotate the whole scene on itself (as it if was on a turntable)
about.turntable = "Turntable";
// Make the entire scene turn around (speed of the animation)
about.turntableSpeed = "Geschwindigkeit Turntable";
// Stuffs that I used to make the app
about.credits = "Credits";
// Link to open source projects that I used for the app
about.credits.openSource = "Open-Source";
// Only translate the &
about.credits.arts = "MatCaps & HDRIs";
// Change languages of the app
about.languages = "Sprachen";
about.languages.help = "Die Übersetzung ist verfügbar unter $0";
// Link to the App Website
about.website = "Webseite";
// Link to the App Forum
about.forum = "Forum";
// Link to the App Manual
about.manual = "Handbuch";
// Link to the App Email
about.mail = "Support";
// Link to the App Twitter account
about.twitter = "Twitter";
// Link to the App Instagram account
about.instagram = "Instagram";
// Link to the App Facebook account
about.facebook = "Facebook";
// Link to the App Discord account
about.discord = "Discord";

// Error when an algorithm needs the object to have an hole (usually to fill it)
alert.hole.nothing = "Das Objekt hat keine Löcher!";
// Visibility of the object is off (but should be on)
alert.shape.notVisible = "Das aktuelle Mesh ist unsichtbar!";
// The user tried to trim an object but the selected region didn't touch the object
alert.trim.nothing = "Nichts zu beschneiden.";
// The user tried to trim an object but the selected region completely encompassed the object
alert.trim.full = "Beschneiden abgebrochen: Das Mesh würde vollständig beschnitten werden.";
// In order to extract something, the mesh needs to have painted mask
alert.mask.noExtract = "Nichts zum Extrahieren!";
// In order to split something, the mesh needs to have painted mask
alert.mask.noSplit = "Nichts zum Teilen ausgewählt!";
// List of disabled features when View Mode is selected
alert.view.disabled = "Funktionen im Ansichtsmodus deaktiviert:";
// Primitive Widgets are small ui stuffs in the viewport that the user can interact with to modify an object
alert.view.disabled.widgetPrimitive = "Primitive widgets";
// The object needs to have two parts disconnected
alert.separate.fail = "Kann nicht getrennt werden: Das Objekt hat nur einen Teil!";
// Remesh is when you create a new topology (mesh) on an object
alert.voxelRemesh.success = "Remeshing ausgeführt!";
alert.voxelRemesh.empty = "Remeshing abgebrochen: Das Ergebnis hätte keine Faces mehr.";
// Should not happen or very rarely, input here is an object
alert.voxelRemesh.invalidInput = "Ungültige Eingabe!";
alert.matrix.clone = "Das Objekt wird dupliziert";
// A pivot refers the gizmo 3d position
alert.gizmo.usePivot = "Benutzerdefinierten Drehpunkt (Pivot) verwenden.";
// A pivot refers the gizmo 3d position
alert.gizmo.useAuto = "Automatischen Drehpunkt (Pivot) verwenden.";
// A pivot refers the gizmo 3d position, this mode means we are moving the pivot
alert.gizmo.editPivot = "Aktueller Modus: Drehpunkt (Pivot) bearbeiten";
// A pivot refers the gizmo 3d position
alert.gizmo.editObject = "Aktueller Modus: Objekt bearbeiten.";
// See Glossary (DynTopo)
alert.dynamic.enable = "Dynamic Topology ist aktiviert!";
// See Glossary (DynTopo)
alert.dynamic.disable = "Dynamic Topology ist deaktiviert!";
alert.colorPicker = "Ziehen Sie Ihren Finger auf das Mesh, um eine Farbe auszuwählen.";
// Transform mode is when the user can move the reference (image in the background) with its two fingers
alert.backgroundTransform = "Einfaches Antippen, um den Transformationsmodus zu verlassen.";
alert.view.reset = "Reset Ansicht";
// Snap the view to the nearest aligned 90° angle
alert.view.snap = "Snap-Ansicht";
// Show the painted mask on the mesh
alert.mask.show = "Maske anzeigen";
// Hide the painted mask on the mesh
alert.mask.hide = "Maske ausblenden";
// Selection refers to the objects that are currently selected
alert.selection.lock = "Auswahl sperren";
// Selection refers to the objects that are currently selected
alert.selection.unlock = "Auswahl entsperren";
// Hide the objects that are not selected
alert.selection.isolate = "Auswahl isolieren";
// Show the objects that are hidden
alert.selection.showAll = "Alles anzeigen";
// Project quick saving
alert.quickSave = "Speichere...";
// Painting on the object was hidden but the user did paint the object
alert.forceShowPainting.fill = "Painting anzeigen aktiviert, [Paint all] wurde verwendet.";
// Painting on the object was hidden but the user started to paint on the object
alert.forceShowPainting.tool = "Painting anzeigen aktiviert, Objekt painted.";
// See Glossary (Multiresolution)
alert.multiresLost = "Multiresolution geht verloren!";
// The user is starting an operation that can lead to a crash
alert.range.warning = "Der Detailgrad ist hoch und kann viel Speicherplatz erfordern!";
// Autosave popup
alert.autoSave.auto = "Automatisches Speichern in... $0s";
// The selected object doesn't have any layers
alert.needLayer = "Das aktuelle Werkzeug erfordert eine aktive Ebene.";
// The user decides to hide the painting on the objects
alert.paintingHidden = "Painting ausgeblendet: Im Einstellungsfenster wieder einblenden.";
// The selected object doesn't have any layers
alert.noPartialWireframe = "Das partielle Zeichnen ist deaktiviert, wenn das Drahtgitter (Wireframe) eingeblendet ist.";
// The user has selected a tool that is more intuitive to use when the camera is in orthographic mode
alert.shapeOrthographic = "Erwägen Sie die Verwendung einer orthografischen Kamera, wenn Sie perspektivische Verzerrungen bei der Verwendung von Screen Project vermeiden möchten.";
// Trial version has a limited number of undo
alert.state.trial = "Rückgängig abgebrochen: Sie benutzen die Testversion!";

background = "Hintergrund";
// A flat color will be displayed in the background of the scene
background.color = "Farbe";
// The environment (HDRI) will be displayed in the background
background.environment = "Umgebung";
background.blur = "Unschärfe";
background.exposure = "Belichtung";

// Image that the artist uses as a reference
background.imageEnable = "Referenzbild";
// The image will be displayed in overlay (used as a reference by the artist)
background.imageOverlay = "Overlay";
// Opposite of transparency (Alpha)
background.imageAlpha = "Alpha";
background.imageReset = "Reset Einstellungen";
background.imageTransform = "Umwandeln";
// X screen coordinate of the image reference
background.imageX = "X-Position";
// Y screen coordinate of the image reference
background.imageY = "Y-Position";
// Rotation of the reference image
background.imageRotation = "Rotation";
// Scale of the reference image
background.imageScale = "Skalierung";

// Camera (point of view in 3d)
camera = "Kamera";
// Copy the views
camera.updateView = "Ansicht updaten?";
camera.addView = "Ansicht hinzufügen";
camera.focusOn = "Fokus auf";
// Camera projection, Orthographic or Perspective
camera.projection = "Projektion";
// Camera projection, Orthographic or Perspective
camera.projection.orthographic = "Orthographisch";
// Camera projection, Orthographic or Perspective
camera.projection.perspective = "Perspektivisch";
// camera Vertical Field of View
camera.fov = "Vertikales FoV";
// Camera Field of View hint
camera.focal = "Brennweite $0mm (35mm Sensor)";
// Rotation mode controls how the user will interact with the camera rotation
camera.rotation = "Orbit mode";
// Camera interaction mode, 2 degrees of freedom (synonym: Orbit)
camera.rotation.orbit = "Turntable";
// Camera interaction mode, 3 degrees of freedom
camera.rotation.trackball = "Trackball";
camera.rotation.trackball.help = "Trackball gibt mehr einem mehr Spielraum, man kann die Kamera auch mit 2 Fingern drehen.";
// Camera interaction mode, 1st person view
camera.firstPerson = "";
// How sensitive the camera is (synonym: sensitivity)
camera.speed = "Geschwindigkeit";
// Camera rotation sensitivity
camera.speed.rotation = "Rotation";
// Camera panning sensitivity
camera.speed.panning = "Schwenken (Pan)";
// Camera zooming sensitivity
camera.speed.zooming = "Zoomen";
// Reset camera position
camera.resetView = "Reset Ansicht";
// Align the view (snap to nearest 90° angle)
camera.snapView = "Snap Ansicht";
// The Camera pivot is the point around which the camera rotates
camera.pivot = "Pivot";
// When we double tap on the object with the finger/stylus
camera.doubleTapMesh = "Doppel-Tap Mesh";
// When we double tap on the background with the finger/stylus
camera.doubleTapBackground = "Doppel-Tap Hintergrund";
// When double tapping with the finger/stylus, the camera pivot will be updated
camera.doubleTapPivot = "Update bei Doppel-Tap";
camera.doubleTapPivot.help = "Aktualisieren Sie den Drehpunkt (Pivot) beim doppelten Antippen.";
// Allow new pivot even when zooming outside the object surface
camera.airPivot = "";
camera.airPivot.help = "";
// Update the pivot when you start interacting with the camera
camera.autoPivot = "Bei Kamerabenutzung";
camera.autoPivot.help = "Aktualisieren Sie den Drehpunkt (Pivot), wenn Sie beginnen, mit der Kamera zu hantieren.";
// Move the camera so that it focus on the intersection point
camera.doubleTapFocus = "Fokus";
camera.doubleTapFocus.help = "Wenn Sie doppelt auf das Mesh tippen, schwenkt die Kamera und fokussiert auf den ausgewählten Punkt.";
// Move the camera so that it focus on selected objects
camera.doubleTapFocusSelection = "Fokus auf Auswahl";
camera.doubleTapFocusSelection.help = "Wenn Sie doppelt auf den Hintergrund tippen, wird der Fokus auf das ausgewählte Mesh anstatt auf die gesamte Szene gelegt.";

// Toolbox context (when expanded), multiple objects are selected
context.multiselection = "";

// Curve widget, Preset lets the user chooses between predefined curves
curve.preset = "Preset";
// Curve widget, Custom lets the user edits the curve directly
curve.custom = "Benutzerdefiniert";

// Debug option, the newly created primitives will contains texture coordinates (UVs)
debug.uvPrimitive = "Primitive UVs beibehalten";
debug.uvPrimitive.warning = "Deaktivieren Sie diese Option, wenn Sie keine UVs benötigen (zusätzlicher Speicher).";
debug.uvPrimitive.help = "Momentan werden nur Box und Kugel (Sphere) unterstützt.

Andere Typen werden in Zukunft unterstützt werden.";
// Debug option, Normalize means transforming the data so that it fits in [0-1] the range
debug.uvNormalize = "UVs normalisieren";
debug.uvNormalize.help = "Nomad normalisiert die UVs innerhalb Tile [0-1].";
// Debug option, BFF stands for Boundary First Flattening (no need to translate)
debug.uvBFF = "BFF UVs hinzufügen";
debug.uvBFF.help = "Hinzufügen einer alternativen Unwrapping-Methode (boundary first flattening - BFF).

Beachten Sie, dass BFF zu Überschneidungen führt, wenn Ihre Mesh-Topologie nicht aus einer Scheibe oder Kugel besteht.";
// Debug option, display an window with some debugging logs
debug.logs = "Logs";
// Debug option, overrides the rendering to display the depth buffer
debug.heightmap = "Heightmap";
// Debug options, graphical stuffs
debug.graphics = "Grafik";
// Debug options, generate screenshots with size compatible with the iOS store
debug.thumbnails = "Vorschaubilder erstellen";

// Empty list: there is no projects
file.project.empty = "Sie haben noch kein Projekt gespeichert!";
// The current opened project has some unsaved changes
file.project.unsaved = "Nicht gespeicherte Änderungen!";
// The user will loose its project's unsaved changes
file.project.loseUnsaved = "Sie werden nicht gespeicherte Änderungen verlieren!";
// Indicates to the user that the project thumbnail corresponds to the last manual save
file.project.lastManualSave = "Vorschau der letzten manuellen Speicherung";
// The user is starting a new project but he won't be able to open the current project (because of trial version)
file.project.trialNoOpen = "Testversion: Sie können das aktuelle Projekt nicht mehr öffnen!";
// The user is trying to load a project but he can only reload the current opened project (because of trial version)
file.project.trialOnlyOpen = "Testversion: Sie können nur Ihr aktuelles Projekt wieder öffnen!";

file.project = "Projekt";
// Save current project (or overwrite if the project has already been saved once)
file.project.save = "Speichern";
// E.g: Save "my_project"?
file.project.save.confirm = "$0 speichern?";
// Save to another project (either new one or overriding existing one)
file.project.saveAs = "Speichern als";
// E.g: Overwrite "my_other_project"?
file.project.saveAs.confirm = "$0 überschreiben?";
// Open a project
file.project.open = "Öffnen";
// E.g: Open "my_project"?
file.project.open.confirm = "$0 öffnen?";
// Load another project and add/append all its data to the current scene
file.project.add = "Hinzufügen";
// E;g: Add "my_other_project" to the scene?
file.project.add.confirm = "$0 der Szene hinzufügen?";
// Reset the scene and create a new project
file.project.new = "Neu";
file.project.new.confirm = "Neue Szene erstellen?";
// Delete a project (not corresponding to the currently opened one)
file.project.delete.confirm = "$0 löschen?";
// Delete a project (corresponding to the currently opened one)
file.project.delete.confirmActive = "$0 löschen?

Dies ist das derzeit aktive Projekt!";

// Auto save section
file.project.autoSave = "Auto-Speichern";
file.project.autoSave.confirm = "Automatisches Speichern deaktivieren?";
file.project.autoSave.help = "Speichert Ihr Projekt in regelmäßigen Abständen in einer separaten Datei.
Die automatisch gespeicherte Datei finden Sie in:

$0";
// Interval in minutes in which the auto save popup will appear
file.project.autoSave.popup = "Popup-Zeitüberschreitung";
// In minutes
file.project.autoSave.minutes = "Timer Popup";
// Delete the current autoSave data
file.project.autoSave.delete = "AutoSave löschen";

// Load interface preference settings when opening a scene file
file.load.guiSettings = "GUI-Einstellungen mitladen";
file.load.guiSettings.help = "Beim Öffnen oder Importieren einer Projektdatei werden alle in das Projekt eingebetteten GUI-bezogenen Einstellungen geladen.";
// OBJ have "groups" and "objects", by default groups are ignored, use this option to consider groups as separate objects
file.load.objSplitByGroup = "OBJ-Gruppen beibehalten";
file.load.objSplitByGroup.help = "Wenn diese Option aktiviert ist, teilt Nomad das OBJ in jede Vertex-Gruppe in separate Objekte auf.";
// Merge all the object layers at when loading a file (deleting them in the process)
file.load.mergeLayers = "Layer zusammenführen";
// Ignore the textures present in the file to load
file.load.skipTextures = "Texturen überspringen";
// Do not fiddle with the object topology when loading the file
file.load.keepTopology = "Topologie beibehalten";
file.load.keepTopology.help = "Verwenden Sie diese Option, wenn Sie nicht möchten, dass Nomad die Topologie des importierten Meshes verändert.

Es deaktiviert das Neuanordnen von Vertices/Faces, das Entfernen von Vertex-/Face-Duplikaten und das Entfernen von unbenutzten Vertices.";
// If the object has more vertices than this value, then we won't attemp to reverse (multiresolution) the object
file.load.reverseVertices = "";
file.load.reverseVertices.help = "";


// Configure imports option
file.importSettings = "";

// Import file section
file.import.title = "Import";
file.import.title.help = "Unterstützte Formate:
- Wavefront (.obj)
- glTF 2.0 (.glb .gltf)
- STL (.stl)";
// The user imports a scene file that will replace the current scene
file.importOpen = "Öffnen";
file.importOpen.confirm = "Neue Datei importieren?";
// The user imports a scene file that will be added/appended the current scene
file.import.add = "Der Szene hinzufügen";
file.import.add.confirm = "Neue Datei importieren?";

// Export scene file
file.export.title = "Export";
file.export.title.help = "Wählen Sie den glTF-Export falls möglich. Das glTF-Format unterstützt beim Export mehr Funktionen als andere Formate.

Nicht jedes Programm kann allerdings glTF importieren.";

// Export the current selected mesh instead of the entire scene
file.exportSelection = "Nur Auswahl exportieren";
file.exportSelection.help = "Exportieren Sie nur das aktuell ausgewählte Mesh anstelle der gesamten Szene.";
// Tries to generate quad (rectangle polygon) from triangles
file.convertToQuad = "Vierecke wiederherstellen";
file.convertToQuad.help = "Wiederherstellen von Vierecken aus Dreiecken durch Paarung von Dreiecken (wenn sie in den Dateien benachbart sind).";

// Whether we include the textures in the exported file
file.export.texture = "Texturen exportieren";
// Baking means transfering/converting 
file.export.texture.help = "Mit dieser Option werden keine Vertex-Farben in die Texturen eingefügt (kein Baking).";
// Whether we include normals vector in the exported file
file.export.normal = "Normale exportieren";
file.export.normal.help = "Aktivieren Sie diese Option, wenn Sie die Datei in einer anderen Software öffnen möchten.

Nomad ignoriert immer die Normale, da es sie neu berechnet.";

file.export.gltf = "glTF 2.0 exportieren";
// Whether we include layers in the exported file (see glossary for layer)
file.export.gltf.layer = "Layer exportieren";
file.export.gltf.layer.help = "Exportieren Sie Ebenen als Morphs. Offiziell von glTF unterstützt, so dass es auch in anderen Programmen funktionieren sollte.";
// Whether we include painting of layers in the exported file (see glossary for layer)
file.export.gltf.layerPaint = "Zusätzliche Material-Layer exportieren";
file.export.gltf.layerPaint.help = "Exportieren Sie Roughness, Metalness, Masken und Layer-Painting. Dies wird von anderen Programmen als Nomad ignoriert werden.";
// Whether the exported layer will use the non-standard Nomad encoding (smaller size)
file.export.gltf.layerNomad = "";
file.export.gltf.layerNomad.help = "";
// Whether we include the vertex color in the exported file
file.export.gltf.color0 = "Vertex-Farben exportieren";
file.export.gltf.color0.help = "Exportieren Sie Vertex-Farben. Offiziell von glTF unterstützt, so dass es auch in anderen Programmen funktionieren sollte.";
// Whether we include the vertex roughness and vertex metalness in the exported file
file.export.gltf.color1 = "";
file.export.gltf.color1.help = "";

file.export.obj = "OBJ exportieren";
file.export.obj.warning = "Layer und zusätzliches Painting (Roughness, Metalness, Masken) gehen verloren.";
// Whether we include the vertex color in the exported file
file.export.obj.colorAppend = "Vertex-Farben exportieren";
file.export.obj.colorAppend.help = "Farbinformationen nach Vertices einfügen.

Einige 3D-Programme können dies importieren, aber nicht alle.";

file.export.stl = "STL exportieren";
file.export.stl.warning = "Layer und zusätzliches Painting (Roughness, Metalness, Masken) gehen verloren.";
// Whether we include the vertex color in the exported file
file.export.stl.color = "Vertex-Farben exportieren";
file.export.stl.color.help = "Einige 3D-Programme können dies importieren, aber nicht alle.";
file.export.stl.ascii = "Standardmäßig ist das Format binär.

Sie können auch in das Textformat (ASCII) exportieren, allerdings wird die Datei dann größer.";

// Advanced settings
settings.advanced = "Erweitert";
// Means that all these options will be resetted when the app restarts
settings.notSaved = "Diese Optionen werden nicht in den Einstellungen gespeichert";
settings.reset.title = "Einstellungen";
settings.reset.title.help = "";

// Reset preference settings button
settings.reset = "Reset";
settings.reset.confirm = "";

// Render a screenshot of the scene
file.render = "Render";
// If we include the App Interface in the exported screenshot
file.render.showInterface = "Interface anzeigen";
// Resolution ratio of the exported screenshot
file.render.renderRatio = "Renderfaktor";
file.render.renderRatio.help = "Ein Wert von 1,0 bedeutet, dass Nomad mit der gleichen Auflösung rendert, wie die unten angegebene Bildgröße.

Verwenden Sie diese Option, wenn Sie bei einer bestimmten Auflösung nicht rendern können (Abstürze wegen Speichermangels).";
// Desired size of the exported screenshot
file.render.size = "Endgültige Größe";
// Desired size of the exported screenshot (custom vs predefined size)
file.render.size.custom = "Benutzerdefiniert";
// Screen resolution parameters for the export screenshot features
file.render.screenResolution = "Bildschirm";
// width of exported screenshot
file.render.width = "Breite";
// height of exported screenshot
file.render.height = "Höhe";
// export screenshot of the scene
file.render.export = "PNG exportieren";
file.render.warn = "Die Export-Auflösung ist hoch ($0x$1)!

Stellen Sie sicher, dass Sie Ihr Projekt vorher speichern, für den Fall, dass Ihr Gerät keinen VRAM mehr hat und abstürzt.";
// If true, then the exported screenshot will have transparency data in the image
file.render.transparent = "Transparenter Hintergrund";
file.render.transparent.help = "Diese Option kann nützlich sein, wenn Sie das freigestellte Mesh in eine 2D-Software importieren möchten.

Teilweise Objekttransparenz wird momentan noch nicht unterstützt.";

// Disable this option to have per-tool pressure settings (instead of shared settings)
pressure.useGlobal = "Globale Vorgabe nutzen";
pressure.useGlobal.help = "Standardmäßig haben alle Werkzeuge dieselben Pressure-Settings.

Deaktivieren Sie diese Option, wenn Sie spezielle Pressure-Settings für dieses Werkzeug wünschen.";

// Pencil pressure
pressure.title = "Pressure";
// Pencil/Stylus pressure will be ignored
pressure.noTool = "Dieses Werkzeug verwendet keine Pressure-Settings für den Stift.";
// The tool can support pressure but its selected stroke type will ignore it 
pressure.noGrab = "Grab ignoriert Pressure-Settings.";
// The stylus pressure will impact the tool radius (more pressure -> bigger radius)
pressure.radius = "Radius";
// The stylus pressure will impact the tool intensity (more pressure -> stronger intensity)
pressure.intensity = "Stärke";

// Gesture section (how we handle stylus, finger)
gesture.title = "Gesten";
// Saved in global preference file, it's not linked to a certain tool or project
gesture.title.help = "Diese Optionen gelten immer global.";

// Customize whether finger and/or stylus can move the Camera
gesture.cameraInteraction = "Kamera:";
// Customize whether finger and/or stylus can sculpt on object
gesture.sculptInteraction = "Sculpt:";
// Both the finger and the stylus can perform a certain action (move camera, sculpt, etc)
gesture.interaction.fingerAndStylus = "Finger und Stylus";
// Only the finger can perform a certain action (move camera, sculpt, etc)
gesture.interaction.finger = "Finger";
// Only the stylus can perform a certain action (move camera, sculpt, etc)
gesture.interaction.stylus = "Stylus";

// Drag 3 fingers horizontally on the canvas to rotate the environment, lights and MatCap
gesture.fingerLighting = "Licht-Rotation (3 Finger)";
// Canvas means the scene viewport (the entire screen but excluding the interface)
gesture.fingerLighting.help = "Bewegen Sie 3 Finger horizontal (von links nach rechts oder umgekehrt) auf der dem Arbeitsbereich, um die Umgebung, die Lichter und das MatCap zu rotieren.";
// Drag 3 fingers vertically to edit the tool radius
gesture.fingerRadius = "Tool-Radius bearbeiten (3 Finger)";
// Canvas means the scene viewport (the entire screen but excluding the interface)
gesture.fingerRadius.help = "Bewegen Sie 3 Finger horizontal auf der dem Arbeitsbereich (von oben nach unten = verkleinern, von unten nach oben vergößern), um den Werkzeug-Radius zu verändern.";

// If this option is enabled, finger inputs on screen will use the smoothing tool
gesture.fingerSmooth = "Finger glättet immer";
// If enabled, the pressure will be taken into account even if it's not coming from a recognized stylus
gesture.unknownPressure = "Unerkannten Pressure zulassen";
gesture.unknownPressure.help = "Aktivieren Sie diese Option, wenn Pressure (Druck) mit Ihrem Stift nicht funktioniert oder wenn Sie einen Pressure für den Finger benötigen.";

// Action when we press an Android pencil button
gesture.pencilAction.android = "Stift: Taste";
// Action when we use the Pencil double Tap
gesture.pencilAction.ios = "Stift: Doppel-Tap";
gesture.pencilAction.ios.help = "Nur aktiv für Apple Pencil 2. Generation.";
// Pencil button (or iOS pencil double tap) action: Nothing
gesture.pencilAction.none = "Nichts";
// Pencil button (or iOS pencil double tap) action: Smooth tool
gesture.pencilAction.smooth = "Smooth";
// Pencil button (or iOS pencil double tap) action: flip adding/substracting sculpt matter setting
gesture.pencilAction.alt = "Add/Sub";

// Shortcuts to undo/redo
gesture.history = "Schnelle-Geste";
gesture.history.help = "2-Finger Tap für UnDo.

3-Finger Tap für ReDo.";

// Size rejection is when we try to ignore the palm of the hand when we interact with a tablet
gesture.palmRejection = "Touch Schwelle";
gesture.palmRejection.confirm = "Wenn Sie Probleme bei der Erkennung der Touch-Eingabe haben, stellen Sie sicher, dass diese Option deaktiviert ist!";
gesture.palmRejection.help = "Die Eingabe auf dem Touchdisplay wird abgelehnt, wenn die Größe der Kontaktfläche beim Touch größer ist, als der vorgegebene Wert.

Funktioniert möglicherweise nicht auf jedem Gerät.";
// Size in pixel for the palm rejection feature
gesture.palmRejection.size = "Schwelle für maximale Größe";

// History, list of undo/redo
history = "Verlauf";
// First "undo" state
history.root = "Root";
history.undoConfirm = "Bestätigen Sie das UnDo (Rückgängig machen) all dieser Änderungen?";
history.undoWarning = "Wenn Sie eine nachträgliche Bearbeitung vornehmen, können viele Änderungen verloren gehen.";
// Settings concerning the history stack of undo/redo
history.stack = "Stapel";
// Can limit the stack of undo/redo size
history.limitSize = "Verlaufslimit (MB)";
history.limitSize.help = "Max. Größe des Verlaufs (in MB).

Der Verlauf wird bei der nächsten aufgezeichneten Änderung aktualisiert.";
// Limit the number of undo in the history stack
history.limitStack = "Stapel-Limit";
history.limitStack.help = "Maximale Anzahl von Änderungen, die im Verlauf bleiben.

Der Verlauf wird bei der nächsten aufgezeichneten Änderung aktualisiert.";
// Value where you define how many operations you can undo before it displays a warning
history.rangeProtect = "Schutz des Bereichs";
history.rangeProtect.help = "Wenn Sie weit in der Verlaufsliste zurückgehen, wird ein Bestätigungsdialog angezeigt, bevor viele Änderungen auf einmal rückgängig gemacht werden.";
// When enabled, each time the user undo an operation it will undo the camera position as well
history.restoreCamera = "Reset Kamera";
history.restoreCamera.help = "Aktivieren Sie diese Option, um die gespeicherte Kamera-Ansicht wiederherzustellen, wenn Sie eine Aktion rückgängig machen/wiederherstellen (UnDo/ReDo).";
// Shown during undo
history.state.undo = "UnDo: $0";
// Shown during redo
history.state.redo = "ReDo: $0";
// Shown during undo/redo
history.state.symmetrySplit = "Symmetrie Split";
// Shown during undo/redo
history.state.voxelRemesh = "Voxel Remesh";
// Shown during undo/redo
history.state.surfaceRemesh = "Surface Remesh";
// Shown during undo/redo
history.state.multiresLevel = "Auflösung ändern";
// Shown during undo/redo
history.state.multiresToDynamic = "Multires zu DynTopo";
// Shown during undo/redo (mesh type conversion)
history.state.meshDynamicToStatic = "DynTopo zu Statisch";
// Shown during undo/redo (mesh type conversion)
history.state.meshStaticToDynamic = "Statisch zu DynTopo";

// Interface customization
interface = "Interface";

// UI customization: each row of the list will be bigger
interface.expandList = "UI: Liste erweitern";
// UI customization: each row of the list will be bigger
interface.expandList.help = "Nur eine UI-Option zur einfacheren Listenverwaltung.";

// Add shortcuts buttons to the bottom of the screen
interface.bottomButtons = "Shortcuts hinzufügen (unten)...";

// Interface option (main base color)
interface.colorBase = "Grundfarbe";
// Interface option (accent widget color)
interface.colorSelect = "Widget-Farbe";
// Interface option (if the menus are transparent or opaque)
interface.panelTransparent = "Panel transparent";
// Interface option (panel blurriness, if the menus are transparent)
interface.blurFactor = "Unschärfe";
// Interface option (color of panels, if the menus are transparent)
interface.colorBaseTransparent = "Panel-Farbe";

// Interface color preset style
interface.preset.title = "Farb-Presets";
// Interface color preset style
interface.preset.blurRed = "Rot";
// Interface color preset style
interface.preset.blurBlue = "Blau";
// Interface color preset style
interface.preset.blurGreen = "Grün";
// Interface color preset style
interface.preset.blurYellow = "Gelb";
// Interface color preset style
interface.preset.blackWhite = "S/W";
// Interface color preset style
interface.preset.whiteBlack = "W/S";
// Interface color preset style
interface.preset.lividOrange = "Livid & Orange";
// Interface color preset style
interface.preset.cardboard = "Cardboard";
// Interface color preset style
interface.preset.default = "Standard";

// Reset interface settings
interface.resetAll = "Reset Interface";
interface.resetAll.confirm = "Alle Interface-Einstellungen zurücksetzen?";
// Interface customization
interface.flipTop = "Oben spiegeln";
// Interface customization
interface.flipBottom = "Unten spiegeln";
// Interface customization
interface.flipMiddle = "Mitte spiegeln";
// Interface customization (preview material in the viewport when editing material color)
interface.materialPreview = "Material-Picker Vorschau";
// Interface customization
interface.materialPreview.help = "";
interface.toolbox.hide = "Toolbox ausblenden";
interface.toolboxHide.help = "Aktivieren Sie diese Option, wenn Sie die Toolbox ausblenden möchten.";
// Interface customization (the toolbox is a grid, we can adjust the column count)
interface.toolbox.maxColumn = "Toolbox max. Spalten";
// Reset the tool's order in the toolbox
interface.toolbox.resetOrder = "Reset Anordn. Tools";
// Mirror the curve in the tool falloff
interface.curveToolSymmetric = "";
interface.curveToolSymmetric.help = "";
// Scale the interface
interface.scale = "Gesamt-Skalierung";
// Spacing between widgets
interface.cursorStep = "Vertikale Abstände";
// Width of the interface panels
interface.panelWidth = "Panel-Breite";
// Size of fonts
interface.fontScale = "Schriftgröße";

// (see Glossary for Layer)
layer = "Layer";
// (see Glossary for Layer)
layers.addLayer = "Layer hinzufügen";
// (see Glossary for Layer)
layer.factors = "Kanal-Werte";
// (see Glossary for Layer)
layer.factor = "";
// (see Glossary for Layer)
layer.offset = "";
// (see Glossary for Layer)
layers.title = "Layer";
// (see Glossary for Layer)
layers.title.help = "Ebenen (Layer) können Positionsverschiebungen und Painting aufzeichnen, was für einen nicht-linearen Arbeitsablauf nützlich sein kann.
Zum Beispiel durch das Experimentieren mit verschiedenen Gesichtsausdrücken, ohne sich auf den Verlauf zurückzugreifen, um die Änderungen rückgängig zu machen.

Beim Painting werden die Ebenen von oben nach unten sortiert, d. h. die obersten Ebenen verdecken die unteren.

Sie können einen Teil dieser Maske (und damit den Einfluss dieser Ebene) zurücksetzen, indem Sie das Werkzeug 'DelLayer' verwenden.";
layers.primitive = "Ebenen sind für Grundobjekte (Primitives) nicht verfügbar.";
// When there is no layer selected (see Glossary for Layer)
layers.baseSelected = "Nichts";

light = "Licht";
// Intesity of light
light.intensity = "Stärke";
// The attachment of a light defines how it will move when the user moves the camera
light.attachment = "Anordnung";
// The light will stay still even if the user moves the camera
light.attachment.fixed = "Fixiert";
// The light will move along the camera
light.attachment.camera = "Kamera";
light.attachment.help = "-- Fixiert
Die Ausrichtung des Lichts wird sich nicht ändern.

-- Kamera
Die Ausrichtung des Lichts hängt von der Kamera-Ansicht ab.";
// Light type (directional, spot, point)
light.type = "Typ";
// Directional light (synonym: sun light)
light.type.directional = "Direktional";
// Spot light emits light in a single direction, restricted by a cone shape.
light.type.spot = "Spot";
// Point light emits lights everywhere (synonym: omni, omnidirectional)
light.type.point = "Punkt";
// Cone angle for spot angles
light.spotAngle = "Winkel Lichtkegel";
// Softness of the spot light
light.spotSoftness = "Sanftheit";
// Position of the light
light.position = "";
// Enable or disable shadows for a light
light.shadowCast = "Schatten";
light.shadowType = "";
// https://en.wikipedia.org/wiki/Shadow_mapping
light.shadowType.shadowMap = "";
// Shadows computed with only the information visible on screen
light.shadowType.screenspace = "";
light.shadowType.screenspace.help = "";
// Adjustment to fix artefacts
light.shadowBias = "Bias";
// How blurry the shadow is
light.shadowSoftness = "";
// Contact shadows are small scale shadows (synonym: cavity shadows... maybe)
light.contactShadow = "";
light.contactShadow.help = "";
// Activated the light
light.visible = "Zeigen";
// Move the light in front of the camera (but keeps its inner orientation)
light.resetPosition = "Zentrieren";

// Object's material
material = "Material";
// See glossary
material.pbrRoughnessMetalness.warning = "Roughness und Metalness werden im aktuellen Shading-Modus irgnoriert.";
// See glossary
material.pbrReflectance.warning = "";
// See glossary
material.pbrRefraction.warning = "";
// See glossary
material.pbrSubsurface.warning = "";
// Value that says how much light will change direction when hitting the surface
material.ior = "Lichtbrechungsindex (Refraction)";
// an object-level value that overrides the painting of the mesh
material.paintingOverride = "Painting aufheben";
// The roughness in the inside is turbidity
material.paintingOverride.help = "";
// Glossiness is simply the opposite of roughness
material.refractionSurfaceGlossiness = "Oberflächenglanz";
material.refractionSurfaceGlossiness.help = "- bei 0 nutzt die Oberfläche painted Roughness
- bei 1 ist die Oberfläche völlig glatt";
// Synonym: turbidity
material.refractionInteriorRoughness = "Rauheit innen";
material.refractionInteriorRoughness.help = "- bei 0 wird innen painted Roughness benutzt
- bei 1 ist das Innere völlig rau";
// Set the roughness of the object with a value of 0
material.paintGlossy = "Paint Glossy";
material.paintGlossy.help = "Painting mit Wert Roughness und Metalness von jeweils 0, für eine eine scharfe Brechung.

Dies entspricht der Nutzung des Paint All-Features aus dem Paint-Menü  mit deaktivierten Color- und Roghness-Kanälen";
// Simulate the light being absorbed when it travels through the volume.
material.absorptionEnable = "Absorption";
material.absorptionEnable.help = "Simulieren Sie die Absorption des Lichts, wenn es das Volumen durchbricht.

Dünne Teile werden hell, da sie mehr Licht durchlassen, während dicke Bereiche dunkler sind..

Der Effekt hängt stark von der Mesh-Geometrie ab, es wird nur eine Annäherung an die Mesh-Dicke verwendet.";
material.absorptionFactor = "Faktor";
// Depth means how far the light can travel under the surface
material.subsurfaceDepth = "";
// Enable translucency (same as subsurface but only affect lights that enter a solid and escape from the other side)
material.translucency = "";
material.translucency.help = "";
// Opacity factor, the opposite of transparency (synonym: Alpha)
material.opacity = "Opacity";
// Fully opaque material
material.type.opaque = "Opaque";
// See glossary
material.type.subsurface = "";
material.type.subsurface.help = "";
// Transparency mode, alpha blending
material.type.blending = "Blending";
material.type.blending.help = "";
// Transparency mode
material.type.additive = "Additive";
material.type.additive.help = "";
// Transparency mode based on dithering
// https://en.wikipedia.org/wiki/Dither
material.type.dithering = "Dithering";
material.type.dithering.help = "Das Dithering (Fehlerdiffusion) ist eine Technik um bei Bildern die Illusion einer größeren Farbtiefe zu erzeugen. Dithering ist eine Art des Rasterns.";
// Simulate glass-like material
material.type.refraction = "Refraction";
material.type.refraction.help = "";
material.castShadows = "Wirft Schatten";
material.receiveShadows = "Empfängt Schatten";
// Lights are ignored, the object will be displayed with color only
material.alwaysUnlit = "Immer Unlit";
// Inverse the side of the object triangles
// https://en.wikipedia.org/wiki/Back-face_culling
material.flipCulling = "Umgekehrtes Culling";
// How much light a surface will reflect (synonym: specular)
material.reflectance = "Reflexionsgrad";
material.reflectance.help = "Kontrollieren Sie den Grad der Reflexion, den das Material bei nicht-metallischen Materialien erhält.

In den meisten Fällen sollte der Standardwert verwendet werden (0,5 - was dem Standardwert von 4% reflektiertem Licht bei normalem Winkel entspricht).";

// Menu name
menu.files = "Dateien";
// Menu name
menu.scene = "Szene";
// Menu name
menu.multires = "Multires";
// Menu name
menu.voxel = "Voxel";
// Menu name
menu.dynTopo = "Dyntopo";
// Menu name
menu.topology = "Deci/UV...";
// Menu name
menu.primitive = "Grundformen";
// Menu name
menu.render = "Render";
// Menu name
menu.material = "Material";
// Menu name
menu.postProcess = "Nachbearbeitung";
// Menu name
menu.camera = "Kamera";
// Menu name
menu.background = "Hintergrund";
// Menu name
menu.tool = "Tool";
// Menu name
menu.stroke = "Stroke";
// Menu name
menu.paint = "Paint";
// Menu name
menu.symmetry = "Symmetrie";
// Menu name
menu.pressure = "Pressure";
// Menu name
menu.layers = "Layer";
// Menu name
menu.settings = "Einstellungen";
// Menu name
menu.interface = "Interface";
// Menu name
menu.history = "Verlauf";
// Menu name
menu.historySettings = "Einstellungen";
// Menu name
menu.about = "Über";
// Menu name
menu.debug = "Debug";

// Operation on the object (action)
mesh.action = "Aktion";
// If the object has holes, the algorithm will close them
mesh.holeClose = "Löcher schließen";
// Says how dense (number of triangles) the algorithm will use in order to fill holes
mesh.holeDetail = "Detail";
// If the mesh has disconnected parts, it will be split/separated into objects
mesh.separate = "Trennen";
// When converting the object to a triplanar primitive, some object features will be lost
mesh.triplanar.warning = "Layer, Painting und Multiresolution geht verloren!";
// Resolution of the triplanar grid
mesh.triplanar.resolution = "Auflösung";
// Make the triplanar a regular cube (all 3 dimension equal)
mesh.triplanar.cubic = "Würfelform erzwingen";
// Covnert an object to a triplanar primitive
mesh.triplanar.convert = "Konvertieren";
// Static object means "static topology"
mesh.typeStatic = "Statisch";
// See glossary
mesh.typeMultiresolution = "Multiresolution";
// Dynamic topology 
mesh.typeDynamic = "DynTopo";

// Disable this option to have per-tool material settings (instead of shared settings)
paint.useGlobal = "Globales Material";
paint.useGlobal.help = "Wenn diese Option aktiviert ist, ist das ausgewählte Material dasselbe wie bei den anderen Werkzeugen.

Beachten Sie, dass hier nur die Einstellungen für Roughness, Metalness und Color berücksichtigt werden.";
// The current tool will paint the object if this option is enabled
paint.usePainting = "Stroke painting";
// Factor/Opacity of paint tool
paint.intensity = "Paint Stäke";
// Apply the paint on the object
paint.paintAll = "Füllen";
paint.paintAll.help = "Wendet das aktuelle Material auf das gesamte Mesh ohne maskierte Bereiche an (Paint all).

Maskierte Bereiche und deaktivierte Kanäle werden berücksichtigt und entsprechend ausgespart!";
// Apply the paint on the object but ignore painting intensity (force full intensity)
paint.paintAllForce = "Füllen erzwingen";
paint.strokePainting.title = "Painting";
paint.layerWarning = "Die Kanalmaskierung wird ignoriert, wenn Sie versuchen, sie auf eine Ebene anzuwenden.";
// Brush stroke texture
paint.texture.title = "Textur";
paint.texture.title.help = "Ein Bild, das den Brush Stroke färbt.

Beachten Sie, dass Tiling und Skalierung des Alphas genutzt werden.";
paint.texture.warningEnable = "Stroke Painting muss aktiviert sein, um Texturprojektion zu ermöglichen (Kontrollkästchen oben)!";
paint.texture.warningIgnored = "Das aktuelle Werkzeug kann keine Texturen verwenden!";
// Whether the Brush Alpha will be used to module painting
paint.useAlpha = "Stroke Alpha benutzen";
paint.useAlpha.help = "Verwenden Sie das Alpha-Set im Stroke-Menu um das Painting zu beeinflussen.";
// Whether the Brush Falloff will be used to module painting
paint.useFalloff = "Use stroke falloff";
paint.useFalloff.help = "Nutzen Sie das Falloff im Stroke-Menu um das Painting zu beeinflussen.";

// when the user choose a new item name (through iOS/Android virtual keyboard)
input.name = "Name";
// when the user choose a new number value (through iOS/Android virtual keyboard)
input.number = "Wert";
// when the user choose a new color (through iOS/Android virtual keyboard)
input.hexcolor = "";

// Post process effect
postprocess.mainEnable = "Nachbearbeitung (Post)";
// Quality vs performance
postprocess.quality = "Qualität";
postprocess.quality.help = "Aktivieren Sie diese Optionen, um die Qualität auf Kosten der Leistung zu verbessern.

It will improve:
- Reflektionen
- Ambient Occlusion (AO)
- Tiefenschärfe (DoF - Depth Of Field)";
// More samples means better quality but slower performance
postprocess.maxSamples = "Max. Samples";
// Full resolution (1:1 resolution) instead of half resolution
postprocess.fullResolution = "Volle Auflösung";
// Number of frames that we accumulate (higher value means better quality)
postprocess.accumulateCount = "";
postprocess.accumulateCount.help = "";
// The value is a ratio (0.5 means half resolution 2 means twice the resolution)
postprocess.renderRatio = "Render-Auflösung";
postprocess.renderRatio.warning = "";
postprocess.renderRatio.help = "";
// Temporal Anti-Aliasing (no need to translate "TAA")
postprocess.taaEnable = "Anti-Aliasing (TAA)";
postprocess.taaEnable.help = "Verringert das Flackern, wenn Sie die Kamera bewegen.";
// Screen-space reflection (no need to translate "SSR")
postprocess.ssrEnable = "Reflektion (SSR)";
postprocess.ssrEnable.warning = "SSR ist nur im PBR-Shading-Modus wirksam.";
// Screen-space ambient occlusion (SSAO)
// https://en.wikipedia.org/wiki/Ambient_occlusion
postprocess.ssaoEnable = "Ambient Occlusion (AO)";
// How far the effect spreads
postprocess.ssaoRadius = "Größe";
// How strong the effect is
postprocess.ssaoFactor = "Stärke";
// Adjustment to fix artefacts
postprocess.ssaoBias = "Wölbungs-Bias";
postprocess.ssaoBias.help = "Wie empfindlich der Effekt ist, hängt von der Oberflächenwölbung ab.";
// Depth of Field (bokeh)
// https://en.wikipedia.org/wiki/Depth_of_field
postprocess.dofEnable = "Depth Of Field (DoF)";
// The blur factor behind the focused point 
postprocess.dofBlurFar = "Ferne Unschärfe";
// The blur factor in front of the focused point 
postprocess.dofBlurNear = "Nahe Unschärfe";
postprocess.dofFocusTip = "Tippen Sie auf ein Objekt, um den Fokuspunkt zu ändern.";
// Bloom (light bleeding)
// https://en.wikipedia.org/wiki/Bloom_(shader_effect)
postprocess.bloomEnable = "Leuchten (Bloom)";
// Intensity of the effect
postprocess.bloomIntensity = "Stärke";
// How far the effect spreads
postprocess.bloomRadius = "Radius";
postprocess.bloomRadius.help = "Wie ausgedehnt das Leuchten ist.";
// Luminosity threshold (below this value, no bloom is generated)
postprocess.bloomThreshold = "Schwellenwert";
postprocess.bloomThreshold.help = "Schwellenwert für die Leuchtkraft (Luminosity), um zu entscheiden, ob ein Pixel das Leuchten (Bloom) emittiert oder nicht.
Steht der Wert auf 0, leuchtet alles.";
// https://en.wikipedia.org/wiki/Tone_mapping
postprocess.toneEnable = "Tone-Mapping";
postprocess.toneExposure = "Belichtung";
postprocess.toneContrast = "Kontrast";
postprocess.toneSaturation = "Sättigung";
// No tonemapping operator is used
postprocess.toneMappingNone = "None";
// Color curves
postprocess.curveEnable = "Color-Grading";
// Curve for pixel luminance
postprocess.curve.luminance = "Luminanz";
postprocess.curve.red = "Rot";
postprocess.curve.green = "Grün";
postprocess.curve.blue = "Blau";
postprocess.curveReset = "Kanal neutral";
// Reset color grading curves
postprocess.curveResetAll = "Alles neutral";
// https://en.wikipedia.org/wiki/Chromatic_aberration
postprocess.chromaticEnable = "Chromatische Aberration";
postprocess.chromaticFactor = "Stärke";
// Darking on the edges
postprocess.vignetteEnable = "Vignette";
// How far the effect spreads
postprocess.vignetteSize = "Größe";
// How sharp the edge of the effect is
postprocess.vignetteHardness = "Ausprägung";
// Unblur the image (sharpening)
// https://en.wikipedia.org/wiki/Unsharp_masking
postprocess.sharpnessEnable = "Schärfe";
postprocess.sharpnessFactor = "Stärke";
// Filmic Grain
// https://en.wikipedia.org/wiki/Film_grain
postprocess.grainEnable = "Körnung (Grain)";
postprocess.grainFactor = "Stärke";
// Accentuate the edges of the model
postprocess.curvatureEnable = "Curvature";
// Color/Strength of concave curvature
postprocess.curvatureCavity = "Cavity";
// Color/Strength of convex curvature
postprocess.curvatureBump = "Bump";
// https://en.wikipedia.org/wiki/Pixel_art
postprocess.pixelArtEnable = "";
// Simulate scanline rendering (horizonal line)
postprocess.scanlineEnable = "";
postprocess.scanlineFactor = "";
// Spacing between lines
postprocess.scanlineSpacing = "";

// Geometry Primitive (box, sphere, cylinder, etc)
primitive = "Grundformen";
primitive.box = "Box";
primitive.sphereCube = "Sphere";
primitive.sphereUV = "UV Sphere";
primitive.icosahedron = "Ikosaeder";
primitive.cylinder = "Zylinder";
primitive.cone = "Kegel";
primitive.torus = "Torus";
primitive.lathe = "Lathe";
primitive.tube = "Tube";
primitive.plane = "Plane";
primitive.triplanar = "Triplanar";
primitive.faceXYZ = "";
primitive.faceXYZ.help = "";
primitive.needValidate = "Grundformen müssen validiert werden, damit sie für das Sculpting bereit sind.";

// If enabled, we can edit primitive inside the viewport
primitive.edit = "Edit";
primitive.edit.help = "3D-Bearbeitung im Ansichtsfenster zulassen.

Sie können diese Funktion deaktivieren, wenn Sie mit dem Gizmo oder dem Transformieren-Werkzeug arbeiten möchten, ohne das Grundelement zu ändern.";

// Primitive configuration
primitive.mainConfig = "Parameter";
// Interface section where we change the topology (number of triangles/polygons)
primitive.topology = "Topologie";
// Interface section where we change the geometry (shape of the primitive)
primitive.geometry = "Geometrie";

// Validating the primitive (then it can be sculpted)
primitive.validate = "Validieren";
// Maximum number of faces of the primitives
primitive.maxFaces = "Max. Faces";
primitive.maxFaces.help = "Die maximale Anzahl an Face (Flächen), die eine Grundform haben kann.

Das Limit ist nur aktiv, solange das Primitiv nicht validiert ist, danach ist der Schutz nicht mehr gegeben.";
// Synonym: Flat subdivision
primitive.linear = "Scharfe Kanten";
// Post as "subdivision that occurs after the primitive computation"
primitive.subdivision = "Post Subdivision";

// Radius (of a sphere, torus, etc)
primitive.radius = "Radius";
// Size (of cube x dimension)
primitive.size = "Maße";
primitive.sizeX = "Größe X";
primitive.sizeY = "Größe Y";
primitive.sizeZ = "Größe Z";
// Division only impacts the topology (synonym: resolution)
primitive.division = "Untereilung";
primitive.divisionX = "Untereilung X";
primitive.divisionY = "Untereilung Y";
primitive.divisionZ = "Untereilung Z";
// Angle of torus, etc
primitive.angleX = "Winkel X";
primitive.angleY = "Winkel Y";
primitive.angleZ = "Winkel Z";
// It means we try to keep regular sized quad (square) instead of highly distorted rectangule
primitive.constantDensity = "Konstante Dichte";
// Make sure the shape is perfectly spherical
primitive.projectOnSphere = "Auf Sphere projizieren";
primitive.projectOnSphere.help = "Rastet die Punkte auf einer perfekten Kugel (Sphere) ein.";

// triplanar
primitive.triplanar.title = "Triplanar";
primitive.triplanar.title.help = "Triplanar verwendet die Maskeninformationen von 3 Ebenen, um ein Voxelgitter zu füllen, das dann in Polygone umgewandelt wird.

Wenn Sie die Regler für Division oder Größe benutzen, werden die Painting-Informationen zurückgesetzt (Smoothness kann verwendet werden).

Sie sollten möglichst Symmetrie deaktivieren, da sie wahrscheinlich nicht so funktioniert, wie Sie es erwarten würden.

Sie können die Option 'Topologisch connected' im Maskenfenster verwenden, um eine Plane zu painten, die die anderen Planes beeinflusst.";
// Make sure the box is a regular cube (same 3 dimension)
primitive.triplanarSameSize = "Gleiche Größe (Würfel)";
primitive.triplanarPolish = "Smoothness";
// Mask refers to the painted mask on the triplanar planes
primitive.triplanarResetMask = "Reset Maske";
// One side of a cube (the back plane)
primitive.isolate.back = "Hinten";
// One side of a cube (the right plane)
primitive.isolate.right = "Rechts";
// One side of a cube (the bottom plane)
primitive.isolate.bottom = "Unten";
// Plane
primitive.planeSameSize = "Gleiche Größe  (quadratisch)";
// Make the plane a disk/ellipse instead of a rectangle
primitive.planeDisk = "";
// Box
primitive.boxRegular = "Gleiche Größe  (Würfel)";
// Distance to the snapping point
primitive.tubeSnapOffset = "Snap Offset";
primitive.tubeSnapOffset.help = "Ein Wert von 1,0 entspricht dem Radius des Tubes.";
// Radius of the tube (starting end-point of the tube)
primitive.tubeThicknessStart = "Start-Radius";
// Radius of the tube (ending end-point of the tube)
primitive.tubeThicknessEnd = "End-Radius";
primitive.tubeTwist = "";
primitive.tubeTwistRotate = "";
primitive.tubeTwistRadius = "";
primitive.tubeTwistOffset = "";
primitive.tubeSnap = "Snap";
primitive.torusRadiusOuter = "Außen-Radius";
primitive.torusRadiusInner = "Innen-Radius";
primitive.torusAngle = "Winkel";
primitive.torusAngleOffset = "Winkel-Offset";
primitive.cylinderHeight = "Höhe";
primitive.coneRadius = "Radius";
primitive.coneHeight = "Höhe";
// Hole sub menu (cylinder, tube, etc)
primitive.hole = "Loch";
// Make a hole in the primtive to make it hollow
primitive.hasHole = "Hat ein Loch";
// Make sure the two end-point of a primitive (cylinder, tube, etc) have the same size
primitive.radiusSync = "Gleicher Radius";
primitive.radiusStart = "Anfangsradius";
primitive.radiusEnd = "Endradius";
// Smooth curve https://en.wikipedia.org/wiki/Spline_(mathematics)
primitive.spline = "Spline";

// Import resource (Alpha, Textures, MatCaps, etc)
resource.import = "Import";

scene.title = "Szene";
scene.title.help = "Wenn Sie das Auswahlkästchen verwenden, halten Sie Ihren Finger gedrückt und ziehen Sie ihn, um andere Objekte einfach auszuwählen.";
// Merge 2 objects without modifying the geometry or the topology
scene.mergeSimple = "Simple Merge";
// Merge/weld 2 objects by recomputing all the topology and creating a new object
scene.mergeVoxel = "Voxel Merge";
scene.voxelResolution = "Auflösung";
// The hidden objects will be "substracted" (the object will carve the other object)
scene.subtractionTip = "Subtraction  : Mesh ausblenden (Augensymbol)";
// If all the objects are hidden, only the parts where they intersect (collide) will be kep
scene.intersectionTip = "Intersection : Alle Meshes ausgeblendet";

// General scene display settings
settings.display.title = "Display Einstellungen";
// Wireframe (show triangles and quad edges)
settings.wireframe = "Wireframe";
// Display UV
settings.debugUV = "UV-Checkerboard";
settings.debugUV.help = "Zeigt die Wireframe-UV im Hintergrund an, wenn das Modell UVs hat.

Beachten Sie, dass bei Aktivierung dieser Option auch die Anzeige der Checkerboard-Textur erzwungen wird.";
// If the object is opened (a simple plane for example), two sided means we'll be able to see if from the two sides of the planes
settings.twoSided = "Backface";
settings.twoSided.help = "Faces sind vomn beiden Seiten sichtbar.";
// If we colorize the inverted side of faces
settings.backface.color = "Backface-Farbe";
// Color of the inverted side of faces
settings.backface.colored = "Backfaces einfärben";
// Outline (contour highlight around the selected object)
settings.outline = "Umriss";
// Outline (contour highlight around the selected object)
settings.outline.help = ""
settings.outline.thickness = "Stärke";
// Navigation cube (easy to snap/align the view)
settings.snapCube = "Ansichten-Würfel";
// Move the navigation cube to the bottom of the screen
settings.snapCube.bottom = "Unten";
// Move the navigation cube on the left side of the screen
settings.snapCube.left = "Links";
// Stats (information logs about the scene displayed on screen)
settings.stats = "Statistik";
settings.stats.right = "Rechts";
settings.stats.all = "Gesamte Szene anzeigen";
// Grid
settings.grid = "Raster";
// Cursor
settings.cursor.whileSculpting = "Kreis anzeigen beim Sculpten";
// A small indicator dot
settings.cursor.showDot = "Kleinen Punkt anzeigen";
settings.cursor.showDot.help = "Der Punkt kann als Kameradrehpunkt erscheinen oder wenn Sie sculpten.";
settings.cursor.showRope = "Rope-Stabilisator anzeigen";
// Highlight (the object glows when we select it)
settings.highlight.selection = "";
// Highlight settings
settings.highlight = "";
settings.highlight.duration = "";
// Mesh that are not selected will be dark
settings.darkenUnselected = "Nicht gewählte Meshes abdunkeln";
// https://en.wikipedia.org/wiki/Shading
settings.smoothShading = "Smooth Shading";
// Experimental feature
settings.partialDraw = "Partial Drawing";
settings.partialDraw.help = "Feature noch nicht ausgereift!

Verwenden Sie es, wenn Sie einen relativ kleinen Teil eines High-Poly-Meshes sculpten.

Es sollte das Sculpten snoother machen, aber Sie sollten Wireframe deaktivieren!

Außerdem könnte es bei den Brush-Strokes zu visuellen Artefakten kommen.";
settings.partialDraw.warning = "Vergessen Sie nicht, diese Option zu deaktivieren, wenn die visuellen Artefakte zu sehr stören!";
// Disable this option to force a white uniform paint instead of showing the objects painting
settings.showPainting = "Pinting anzeigen";
// Display the light icons in the viewport
settings.lightIcon = "Licht-Icon";
settings.lightIcon.help = "Icons für die einzelnen Lichter im Arbeitsbereich anzeigen, so dass Sie die Lichter direkt auswählen und bearbeiten können";
// Hole filling settings
settings.hole = "Löcher füllen";
// Allow the hole filling algorithm to handle non-manifold (non regular topology)
settings.hole.nonManifold = "Non-Manifold füllen";
settings.hole.nonManifold.help = "Versucht, ein non-manifold Loch zu füllen.
Diese Option ist nicht in den Einstellungen gespeichert.";
// Maximum number of vertices (points)
settings.multires.maxVertices = "Max. Anzahl an Vertices";
settings.multires.maxVertices.help = "Nomad führt vor der Unterteilung keine Speicherprüfung durch, eine hohe Polyanzahl kann leicht zu Abstürzen führen.";
settings.multires.lowResVertices = "Low Resolution Schwelle";
settings.multires.lowResVertices.help = "Eine geringere Auflösung des Meshes wird angezeigt, wenn Sie die Kamera bewegen.

Sie können diesen Wert erhöhen, wenn Sie eine höhere Auflösung des Meshes anzeigen möchten.";

// The main rendering mode
shading = "Shading";
// main render mode
shading.pbr = "PBR";
shading.pbr.help = "";
shading.matcap = "MatCap";
shading.matcap.help = "";
shading.unlit = "Unlit";
shading.unlit.help = "";
shading.textures = "";
shading.textures.help = "";
// Lights
shading.lights = "Lichter";
shading.lights.addLight = "Licht hinzufügen";
shading.lights.warning = "Lichter werden in den Modi MatCap und Unlit generell ignoriert.";
// Environment based lighting (synonym: HDRI)
shading.environment = "Umgebung";
shading.environmentImport = "HDR importieren";
shading.environmentExposure = "Belichtung";
shading.environmentBackgroundBlur = "";
shading.environmentRotation = "Rotation";
shading.environmentRotation.help = "Sie können die Umgebung drehen, indem Sie 3 Finger horizontal (von links nach rechts oder umgekehrt) auf dem Touchbildschirm bewegen.";
// The environment will always be aligned with the camera (so that the lighting is consistent)
shading.environmentAttachedToCamera = "Mit der Kamera verbunden";
shading.environmentAttachedToCamera.help = " Verbinden Sie die Umgebung mit der Kamera.

Dadurch wird eine gleichmäßige Beleuchtung erzwungen, was für das Sculpting hilfreich sein kann.";
shading.matcapRotation = "Rotation";
shading.matcapRotation.help = "Sie können das MatCap drehen, indem Sie 3 Finger horizontal (von links nach rechts oder umgekehrt) auf dem Touchbildschirm bewegen.";
shading.matcapGlobal = "Globales MatCap verwenden";
shading.matcapGlobal.help = "Deaktivieren Sie diese Option, um ein separates MatCap für dieses Mesh zu verwenden.";

// bottom shortcut buttons (should be SHORT)
shortcut.maskVisible.short = "";
shortcut.maskVisible.long = "";
// bottom shortcut buttons (should be SHORT)
shortcut.solo.short = "";
shortcut.solo.long = "";
// bottom shortcut buttons (should be SHORT)
shortcut.voxelRemesh.short = "";
shortcut.voxelRemesh.long = "Voxel Remesh";
// bottom shortcut buttons (should be SHORT)
shortcut.wireframe.short = "";
shortcut.wireframe.long = "Wireframe";
// bottom shortcut buttons (should be SHORT)
shortcut.cameraReset.short = "";
shortcut.cameraReset.long = "Kamera-Reset";
// bottom shortcut buttons (should be SHORT)
shortcut.cameraSnap.short = "";
shortcut.cameraSnap.long = "Kamera-Snap";
// bottom shortcut buttons (should be SHORT)
shortcut.lockSelection.short = "";
shortcut.lockSelection.long = "Selektion einfrieren";
shortcut.lockSelection.long.help = "Wenn diese Funktion aktiviert ist, können Sie die Auswahl nicht ändern, indem Sie auf ein Mesh tippen.";
// bottom shortcut buttons (should be SHORT)
shortcut.perspective.short = "";
shortcut.perspective.long = "Perspektive";
// bottom shortcut buttons (should be SHORT)
shortcut.grid.short = "";
shortcut.grid.long = "";
// bottom shortcut buttons (should be SHORT)
shortcut.uv.short = "";
shortcut.uv.long = "";

// Memory taken by the scene
stat.ramScene = "Szene";
// Vram = Video RAM (Video Memory, the memory of the graphic card) 
stat.vramScene = "VRAM Szene";
// Vram = Video RAM (Video Memory, the memory of the graphic card) 
stat.vramRender = "VRAM Render";
// Vram = Video RAM (Video Memory, the memory of the graphic card) 
stat.vramTextures = "VRAM Texturen";
// Memory taken by the undo/redo history
stat.ramHistory = "Verlauf";
// Memory taken by other stuffs
stat.ramOther = "Anderes";
// Memory used by the app (RAM, not storage!)
stat.usedMemory = "RAM benutzt";
// Memory available for the app (RAM, not storage!)
stat.freeMemory = "RAM frei";
// RAM, not storage!
stat.ram = "RAM";
stat.used = "Benutzt: $0 MB";
stat.free = "Frei: $0 MB";
stat.faces = "Faces";
stat.triangles = "Dreiecke";
stat.vertices = "Vertices";
// quadrangular polygon (polygon with 4 sides)
stat.quads = "Quads";
stat.sceneFaces = "Faces in Szene";
stat.sceneVertices = "Vertices in Szene";

// Brush stroke
stroke = "Stroke";
// The brush radius is either screen-space (fixed size on the screen) or world-space (fixed size in the scene)
stroke.useWorldRadius = "World-Space Radius";
// The settings is shared among every tools
stroke.useWorldRadius.help = "Das wird von allen Werkzeugen geteilt.";
// Share the radius value among every tools.
stroke.useShareRadius = "Radius teilen";
stroke.useShareRadius.help = "Teilen Sie den Wert des Radius auf mit allen Werkzeugen.";
// When doing a brush stroke, the spacing is the distance between 2 sculpt operations
stroke.minSpacing = "Stroke Spacing";
// Adjust the brush intensity to ensure consistent deformation depending on the stroke spacing.
stroke.minSpacing.adjustIntensity = "Intensität der Abstände anpassen";
stroke.minSpacingAdjustIntensity.help = "Passen Sie die Brush-Intensität an, um eine gleichmäßige Verformung in Abhängigkeit von den Stroke-Abständen zu gewährleisten.";
stroke.minSpacing.help = "Abstand zwischen den einzelnen Strokes (Strichen), relativ zum Werkzeugradius.

Ein niedrigerer Wert ermöglicht einen gleichmäßigeren Stroke, aber die Leistung nimmt ab.";
// Brush stroke smoothing
stroke.lazySmooth = "Stroke Smoothing";
stroke.lazySmooth.help = "Mittlere Position des Pointers, um einen gleichmäßigeren Stroke zu erhalten.

Bei hohen Werten hinkt der Strich dem Pointer hinterher, holt aber schließlich auf.";
// Make the brush stroke lags behind the pointer cursor
stroke.lazyRadius = "Lazy Rope Stabilisator";
stroke.lazyRadius.help = "Die Strokes bleiben in einem bestimmten Abstand hinter der Pointer-Position.

Damit kann man geglättete Linien zeichnen.";
// It is not a per-tool settings
stroke.globalSettings = "Dies ist eine globale Einstellung";
// Start the brush stroke from the last sculpted position to ensure there is no discontinuity
stroke.snapRadius = "Snap Radius";
stroke.snapRadius.help = "Rastet den Stroke ein, wenn der Pointer in der Nähe des letzten aufgezeichneten Strokes liegt.

Das kann nützlich sein, wenn man lange, durchgehende Linien zeichnet und dabei häufig Pausen macht.";
// offset between the cursor and the brush stroke (for fat finger on small screen)
stroke.sculptOffset = "Stroke-Offset";
stroke.sculptOffset.help = "Wendet einen konstanten Offset auf den Stroke an.

Diese Option ist für kleine Bildschirme gedacht, wenn man mit den Fingern arbeitet, damit der Finger nicht den Stroke verdecken.";
stroke.accumulate = "Strokes kumulieren";
stroke.accumulate.help = "Wenn diese Option aktiviert ist, gibt es keine Begrenzung für die Menge an Material, die Sie je Stroke hinzufügen/entfernen können.";
// The tool can use DynTopo
stroke.useDynamicTopology = "Dynamic Topology erlauben";
// Only sculpt the part that are linked topologically
stroke.connectedTopology = "Connected Topology";
stroke.connectedTopology.help = "Mit dieser Option werden nur die Vertices gesculptet, die mit der ausgewählten Oberfläche verbunden sind.

Dies wird in der Regel für das Move-Werkzeug verwendet, zum Beispiel, wenn Sie ausschließlich ein Teil verschieben möchten, das sich mit einem anderen Teil überschneidet.";
// Only sculpt the vertex that points toward the camera
stroke.onlyFrontFace = "Nur Front-Facing Vertex";
stroke.onlyFrontFace.help = "Diese Option ignoriert Back Face Vertices.

Dies kann nützlich sein, wenn Sie einen Teil einer dünnen Geometrie painten wollen, ohne die andere Seite zu beeinträchtigen.

Dies funktioniert auch für das Sculpting, aber es kann zu Artefakten kommen.";
// Only sculpt the vertex that points toward the direction of the deformation
stroke.onlySameSide = "Vertices gleicher Ausrichtung";
stroke.onlySameSide.help = "Vertices, die in die entgegengesetzte Richtung der Deformation zeigen, werden ignoriert";
// Module the intensity of the sculpting operation by using a falloff curve
stroke.curveFalloff = "Falloff";
stroke.onlyLasso = "Einstellungen nur für das Lasso-Werkzeug aktiv.";
// Alpha
stroke.alpha = "Alpha";
// Invert the pixel (black <-> white)
stroke.alphaInvert = "Alpha invertieren";
// Repeat the alpha image (pattern)
stroke.alphaWrap = "Tiling";
// No repeat pattern
stroke.alphaWrap.none = "Kein";
// Repeat the alpha in a regular manner (tiles with seams)
stroke.alphaWrap.repeat = "Wiederholen";
// Repeat the alpha in a mirrored (seamless tiling)
stroke.alphaWrap.mirror = "Spiegeln";
stroke.alphaProject = "Methode";
// Project the alpha perpendicularly onto the surface 
stroke.alphaProject.surfaceContinuous = "Oberfläche";
// Project the alpha onto the surface in the direction of the camera view
stroke.alphaProject.screenFixed = "Screen Project";
// Repeat the image
stroke.alphaTiling = "Tiling";
// Scale the image (make it bigger or smaller)
stroke.alphaScale = "Scaling";
stroke.alphaScale.help = "Beim Minimalwert liegt das Alpha-Quadrat innerhalb des Werkzeugkreisradius";
// Middle-point value at which no deformation occurs
stroke.alphaMidValue = "Mittelwert";
stroke.alphaMidValue.help = "Mittelwert, bei dem keine Verformung auftritt.

(Mittelwert = 0)
- Schwarz: Kein Displacement
- Weiß: Positives Displacement

(Mittelwert = 0.5)
- Schwarz: Negatives Displacement
- Weiß: Positives Displacement

(Mittelwert = 1)
- Schwarz: Negatives Displacement
- Weiß: Kein Displacement";
// Stroke type
stroke.strokeType = "Stroke Typen";
// Sculpt and paint along the brush stroke at regular spacing
stroke.strokeTypeDot = "Dot";
// Sculpt continuously
stroke.strokeTypeDrag = "Drag";
// Lock a region and move it around
stroke.strokeTypeGrab = "Grab";
// Lock a point of interest and sculpt it by changing the tool radius
stroke.strokeTypeGrabRadius = "Grab - Dynamischer Radius";
// Lock a region and sculpt it by changing the tool intensity
stroke.strokeTypeGrabIntensity = "Grab - Dynamische Intensität";

// Symmetry
symmetry = "Symmetrie";
symmetry.enable = "Aktiviert";
symmetry.plane.title = "Planes";
symmetry.toolIgnore = "Das aktuelle Werkzeug ignoriert Symmetrie.";
// Instead of planar symmetry, use a radial symmetry
symmetry.radial.title = "Radial";
symmetry.radialX = "Radial X";
symmetry.radialY = "Radial Y";
symmetry.radialZ = "Radial Z";
// method
symmetry.method = "Methode:";
symmetry.method.help = "-- Lokal
Die Symmetrieebene wird entlang des Meshes verschoben, wenn Sie eines der Transformationswerkzeuge (Transform oder Gizmo) verwenden.


-- Welt
The symmetry plane is fixed and will not move.";
// Local means: in the coordinate of the scene 
symmetry.methodWorld = "Welt";
// Local means: in the coordinate of the object (internal) 
symmetry.methodLocal = "Lokal";
// Move the object to the other side of the symmetry (mirror it as well)
symmetry.flip = "Objekt umdrehen";
// Mirror the mesh
symmetry.mirror = "Spiegelung";
symmetry.mirror.help = "Versuchen Sie, die Symmetrie wiederherzustellen, ohne die Topologie zu beeinträchtigen.

Radiale Symmetrie wird ignoriert.

Wenn die Topologie nicht beibehalten werden kann, weil sie nicht als symmetrisch angesehen wird, erhalten Sie die Möglichkeit, die Spiegelung dennoch zu erzwingen.";
symmetry.mirrorLeftToRight = "Von links nach rechts";
symmetry.mirrorRightToLeft = "Von rechts nach links";
symmetry.mirrorFail = "Versuch die Symmetrie anzuwenden fehlgeschlagen.

Wollen Sie die Symmetrie durch Spiegelung des Meshes erzwingen?";
symmetry.mirrorUseMasking = "Maskierte bBereiche schützen";
symmetry.mirrorUseMasking.help = "Lässt den maskierten Bereich intakt.

Diese Option wird bei nicht-symmetrischer Topologie (oder unzusammenhängender Oberfläche, wie einem Augenpaar) ignoriert.";
// Reset the symmetry plane position
symmetry.reset = "Reset";
// Reset the symmetry plane positon to the object center
symmetry.reset.centerMesh = "Mesh Zentrum";
// Reset the symmetry plane positon to the scene (world) center
symmetry.reset.centerWorld = "Welt Zentrum";
// Reset the symmetry plane orientation
symmetry.reset.direction = "Orientierung";
// Display a line on the object (to show where the symmetry lies)
symmetry.showLine = "Line anzeigen";
// Display the symmetry plane in 3d
symmetry.showPlane = "Plane anzeigen";
// Allow the editing of the symmetry plane with the gizmo
symmetry.edit = "Gizmo bearbeiten";
symmetry.edit.warning = "Symmetriebearbeitung ist experimentell";
symmetry.edit.help = "Sie können die Symmetrieebene frei festlegen.

Diese Funktion ist ein wenig experimentell und Sie sollten sie vermutlich nicht verwenden.";

// Ideally <10 chars
tool.dynTopo = "DynTopo";
// Ideally <10 chars (Symmetry)
tool.symmetry = "Sym";
// Ideally <10 chars (Mirror primitive)
tool.mirror = "Mirror";
// Ideally <10 chars
tool.clay = "Clay";
// Ideally <10 chars (Subtract)
tool.clay.sub = "Sub";
// Ideally <10 chars
tool.brush = "Brush";
// Ideally <10 chars
tool.move = "Move";
// Ideally <10 chars (Normal vector, perpendicular to surface)
tool.move.normal = "Normal";
// Ideally <10 chars
tool.drag = "Drag";
// Ideally <10 chars (Smooth the surface by erasing the details)
tool.smooth = "Smooth";
// Ideally <10 chars (Tries to smooth the topology by making the polygons more regular)
tool.smooth.relax = "Relax";
// Ideally <10 chars (Paint mask)
tool.mask = "Mask";
// Ideally <10 chars
tool.mask.unmask = "Unmask";
// Ideally <10 chars (Selector Mask, use lasso/ellipse,etc shape to mask the mesh)
tool.maskSelector = "SelMask";
// Ideally <10 chars (Smudge the paint of the object)
tool.smudge = "Smudge";
// Ideally <10 chars (Flatten the surface)
tool.flatten = "Flatten";
// Ideally <10 chars (Flatten the surface by offsetting the surface in the opposite direction)
tool.flatten.fill = "Fill";
// Ideally <10 chars (Layer brush)
tool.layer = "Layer";
// Ideally <10 chars
tool.crease = "Crease";
// Ideally <10 chars (Cut part of the mesh cleanly)
tool.trim = "Trim";
// Ideally <10 chars (Cut part of the mesh cleanly into two separate meshes)
tool.split = "Split";
// Ideally <10 chars (Project part of the object onto a curve)
tool.project = "Project";
// Ideally <10 chars
tool.inflate = "Inflate";
// Ideally <10 chars
tool.pinch = "Pinch";
// Ideally <10 chars
tool.nudge = "Nudge";
// Ideally <10 chars
tool.stamp = "Stamp";
// Ideally <10 chars (Delete Layer, a tool that can cancel the Layer deformation/paint)
tool.clearLayer = "DelLayer";
// Ideally <10 chars (Select multiple objects with a lasso tool)
tool.lassoSelect = "";
// Ideally <10 chars (Rotate, Translate and Scale the object)
tool.gizmo = "Gizmo";
// Ideally <10 chars (Automatic)
tool.gizmo.auto = "Auto";
// Ideally <10 chars
tool.gizmo.editPivot = "Pivot";
// Ideally <10 chars (Snap angle)
tool.gizmo.rotateSnap = "Snap";
// Ideally <10 chars (Local space)
tool.gizmo.local = "Local";
// Ideally <10 chars (Rotate, Translate and Scale the object)
tool.transform = "Transform";
// Ideally <10 chars (Translate the object)
tool.transform.move = "Move";
// Ideally <10 chars (Rotate the object)
tool.transform.rotate = "Rotate";
// Ideally <10 chars (Scale the object)
tool.transform.scale = "Scale";
// Ideally <10 chars (Snap the object on another object surface)
tool.transform.snap = "Snap";
// Ideally <10 chars (Measure distance between 2 points)
tool.measure = "Measure";
// Ideally <10 chars (View tool, do nothing in particular)
tool.view = "View";
// Ideally <10 chars (Revolving surface along a line)
tool.lathe = "Lathe";
// Ideally <10 chars (Revolving surface along a curve)
tool.tube = "Tube";
// Ideally <10 chars (Insert object into the scene)
tool.insert = "Insert";
// Ideally <10 chars (Flip/Invert/Negate the shape)
tool.shape.flip = "Flip";
// Ideally <10 chars (View, do nothing in particular)
tool.shape.view = "View";
// Ideally <10 chars (Lasso selection)
tool.shape.lasso = "Lasso";
// Ideally <10 chars (Curve selection, same as Lasso and it's an open shape)
tool.shape.curve = "Curve";
// Ideally <10 chars (Polygon selection, same as Lasso but with more precision)
tool.shape.polygon = "Polygon";
// Ideally <10 chars (Path selection, same as Lasso but with more precision and it's an open shape)
tool.shape.path = "Path";
// Ideally <10 chars (Rectangular selection)
tool.shape.rectangle = "Rect";
// Ideally <10 chars (Ellipse selection)
tool.shape.ellipse = "Ellipse";
// Ideally <10 chars (Line selection, split the screen in half)
tool.shape.line = "Line";
// Ideally <10 chars (Whether a shape is closed or not, a tube is open, a torus is closed)
tool.shape.closed = "Closed";

// Popup when editing the vertical sliders on the left
tool.slider.radius = "Radius $0";
// Popup when editing the vertical sliders on the left
tool.slider.intensity = "Stärke $0 %";

tool.settings = "Werkzeugeinstellungen";
tool.settings.none = "Dieses Werkzeug hat keine besonderen Einstellmöglichkeiten.";

// Flatten distance offset
tool.clay.flattenOffset = "Flatten Offset";
tool.crease.pinchFactor = "Pinch Kraft";

tool.layer.removeInfluence = "Aktuellen Layer Offset verwenden";
tool.layer.removeInfluence.help = "Diese Option ist nur aktiv, wenn ein aktueller Layer ausgewählt ist.

Es wird der aktuelle Layer Offset verwendet, um das Displacement über Strokes zu begrenzen.";
tool.layer.noLayerSelected = "Diese Option ist nur verfügbar, wenn ein aktueller Layer ausgewählt ist";

tool.flatten.warning = "Diese Optionen sind experimentell und könnten zukünftig entfallen!";
tool.flatten.planeLockOrigin = "Plane Origin sperren";
tool.flatten.planeLockNormal = "Plane Ausrichtung sperren";
tool.flatten.planeAverageOrigin = "Durchschnittlicher Plane Origin";
tool.flatten.planeAverageNormal = "Durchschnittliche Plane Ausrichtung";
tool.flatten.planeOffset = "Plane Offset";

// The vertex on the border of the mesh will stay still even if we try to smooth the border
tool.smooth.stickyBorder = "Sticky Vertex am Rand";

tool.paint = "Paint";
// Erase the painting
tool.paint.erase = "Löschen";
// Only paint the part of the mesh above a certain height
tool.paint.depthFilter = "Depth Filter";
// Only paint the part of the mesh that was already painted in the layer (repainting)
tool.paint.layerFilter = "Layer Filter";
tool.paint.layerFilter.help = "Verwenden Sie diese Option, wenn Sie nur den bereits gepainteten Bereich eines Layers erneut painten wollen.";

// Clear the painted mask
tool.mask.clear = "Löschen";
// Invert the painted mask
tool.mask.invert = "Umkehren";
// Mask or Unmask a region (leave other region that unconnected intact)
tool.mask.flipConnected = "Flip Connected";
// Blur the painted mask
tool.mask.blur = "Blur";
// Sharpen the edge of the painted mask area
tool.mask.sharpen = "Schärfen";
// The thickness of the extracted mesh (from the painted mask)
tool.mask.thickness = "Shell Dicke";
// Smooth the border of the extracted mesh (from the painted mask)
tool.mask.polish = "Rand Smoothness";
// Extract a new mesh from the painteed mask and carve/emboss the base mesh
tool.mask.engraveEmboss = "Gravieren / Prägen";
// Extract a new mesh from the painted mask
tool.mask.extract = "Extrahieren";
// Extract two new mesh from the painted mask and from the unmasked area
tool.mask.split = "Teilen";
// How should we close the topology of the extracted object
tool.mask.closeMask = "Closing Aktion (maskiert):";
// How should we close the topology of the extracted object
tool.mask.closeUnmask = "Closing Aktion (unmaskiert):";
// How should we close the topology of the extracted object
tool.mask.closeAction = "Closing Aktion:";
// Do not close the mesh (leave it open)
tool.mask.closeActionNone = "Keine";
// Close the mesh with a hole-filling algorithm
tool.mask.closeActionFill = "Fill";
// Close the mesh by adding a thickness on the surface
tool.mask.closeActionShell = "Shell";
// Close the mesh by using the layer data as a difference thickness
tool.mask.closeActionLayer = "Layer";
tool.mask.closeAction.help = "-- Keine
Extrahiert einfach den Bereich und lässt das extrahierte Teil offen.

-- Fill
Das Loch wird gefüllt und geglättet.
Verwenden Sie diese Option nicht für ebene Oberflächen.

-- Shell
Schließt die extrahierte Form mit Hilfe des Dickenwerts.

-- Layer
Extrahiert die Layer-Differenz (nur Layer-Untermenü).";

// Transform/Matrix
tool.matrix = "Matrix";
// Duplicate/Clone the mesh when interacting with the gizmo
tool.matrix.clone = "Klonen";
// The target of the transform is either the Matrix or the Vertex of the object
tool.matrix.apply = "";
// Automatic
tool.matrix.apply.auto = "Auto";
// Vertex/Point of a mesh
tool.matrix.apply.vertex = "Vertex";
// Object-level transform (Matrix)
tool.matrix.apply.object = "Objekt";
tool.matrix.apply.help = "-- Auto
Lassen Sie Nomad zwischen dem Vertex- und dem Objektmodus wählen.
Normalerweise wird Objekt bevorzugt, es sei denn, die Symmetrie ist aktiviert oder das Mesh ist maskiert.

-- Vertex
Vertices werden einzeln transformiert.
Symmetrie und Masken werden dabei berücksichtigt.
Für Grundformen, die nicht validiert sind, wird der Objektmodus erzwungen.

-- Objekt
Das Objekt wird als Ganzes transformiert.
Symmetrie und Masken werden ignoriert.
Wenn Sie eine ungleichmäßige Skalierung verwenden, wird der Vertex-Modus erzwungen.";
// Operation on the mesh
tool.matrix.action = "Aktion";
tool.matrix.action.help = "-- Move Origin
Bewegt das Mesh zum Welt Origin (Ursprung).

-- Reset
Setzt die Mesh-Transformation auf Identität zurück.

-- Bake
Wendet die Matrix auf den Vertex an und setzt die Matrix zurück. Visuell sollte sich nichts ändern.";
tool.matrix.translation = "Translation";
tool.matrix.rotation = "Rotation";
tool.matrix.scale = "Skalierung";
tool.matrix.uniformScale = "Gleichmäßige Skalierung";
tool.matrix.uniformScale.help = "Nomad kann keine ungleichmäßige Skalierung als Objekttransformation unterstützen, daher wird sie als Vertex-Transformation angewendet.";
tool.matrix.moveToOrigin = "Move Origin";
tool.matrix.resetTransform = "Reset";
// Synonym: Apply (transform)
tool.matrix.bakeTransform = "Backen";

tool.transform.multiTouch = "Multi-Touch";
tool.transform.multiTouch.help = "Wenn diese Option deaktiviert ist, können Sie jeweils nur einen Modus (Translate, Rotate, Skalieren) verwenden.";
tool.transform.transformRestrictRotationY = "";
tool.transform.transformRestrictRotationY.help = "";

// Size of the gizmo
tool.gizmo.size = "Widget-Größe";
tool.gizmo.linearRollThreshold = "Tangentiales Rollen";
tool.gizmo.linearRollThreshold.help = " Schwellenwert des Winkels für die Wahl zwischen linearer und kreisförmiger Roll-Methode.

Bei Werten über diesem Schwellenwert wird die kreisförmige Roll-Methode verwendet.

Wenn Sie die lineare Drehung (Richtung der Tangente) bevorzugen, setzen Sie diesen Wert einfach auf 90°.";
// Partially hide/fade the gizmo when we interact with it
tool.gizmo.autoHide = "Ausblenden bei Interaktion";
tool.gizmo.tap = "Pivot Einfach-Tap";
tool.gizmo.tap.help = "Diese Option ist nur im benutzerdefinierten Pivot-Modus wirksam (Auto deaktiviert).

-- Keiner
Beim Antippen des Meshes passiert nichts.

-- Erster Treffer
Bewegt das Gizmo auf die erste Schnittstelle.

-- Mittlerer
Bewegt das Gizmo auf den Durchschnitt der ersten beiden Schnittpunkte.";
tool.gizmo.tapNone = "Keiner";
tool.gizmo.tapFirstHit = "Erster Treffer";
tool.gizmo.tapMiddleStab = "Mittlerer";

tool.lathe.axis = "Achse";
// The lathe generator (line) is fixed on the screen
tool.lathe.axis.fixed = "Fixiert";
// synonym: Start & End, Custom
tool.lathe.axis.dynamic = "Dynamisch";

tool.tube.snap = "Snapping";
// Snap everything of the tube on the surface
tool.tube.snap.all = "Jeder Punkt";
// Snap only the first and last control point of the tube on the surface
tool.tube.snap.startEnd = "Start & Ende";

// Fill the object's hole
tool.hole = "Füllen von Löchern";
tool.hole.fillHoles = "Löcher füllen";
// synonym: Alternative method
tool.hole.bridges = "Screen-Space Boolean";
tool.hole.bridges.help = "Wenn diese Option aktiviert ist, können Sie Löcher in das Volumen stechen.
Auch die Schnittneigung wird sich stärker an der Schnittform orientieren.";
tool.hole.threshold = "Schwellenwert Epsilon";
tool.hole.threshold.help = "Eine Optimierung dieses Wertes könnte den Algorithmus zum Füllen von Löchern unterstützen.";
tool.hole.smoothing = "Loch-Glättung";

tool.smudge.quality = "Qualität";
tool.smudge.quality.help = "Es ändert die Auflösung der projizierten Pixel, niedrigere Werte bedeuten schnellere Striche (Strokes).";

// Shape for the tools: Trim / Split / Project / SelMask
tool.shape = "Shape";
// Force the rectangle selection to be a square
tool.shape.rectangleSquare = "Quadrat";
// The selection rectangle will be centered around the cursor
tool.shape.rectangleCentered = "Zentriert";
// Force the ellipse selection to be a circle
tool.shape.ellipseCircle = "Kreis";
// The selection ellipse will be centered around the cursor
tool.shape.ellipseCentered = "Zentriert";
// Rotate by step (angle value)
tool.shape.lineRotateStep = "Rotate Schritt";

// Show a yellow dot on the golden ratio point
tool.measure.goldenRatio = "Goldenen Schnitt anzeigen";

// Topology
topology = "Topologie";
// Synynom: detail value, density
topology.dynamic.detail = "Detail";
// See glossary
topology.multires.title = "Multiresolution";
topology.multires.title.help = "Keep multiple resolution of a mesh.

Wenn Sie Änderungen in einer niedrigeren Auflösung vornehmen, werden die Details aus der höheren Auflösung beim Zurückschalten erneut projiziert.

Layer sind in jeder Auflösung verfügbar.";
// Synonym: Unsubdivide, Un-subdivide
topology.multiresReverse = "Reverse";
topology.multiresReverse.confirm = "Konnte keine Basis-Subdivision erstellen.

Die derzeitige Topologie ist wahrscheinlich nicht das Ergebnis einer Subdivision";
topology.multiresSubdivide = "Subdivide";
topology.multiresSubdivideConfirm = "Das Mesh wird $0M Vertices aufweisen, sind Sie sicher?";
topology.multiresDeleteLower = "Niedriger löschen";
topology.multiresDeleteHigher = "Höher löschen";
topology.multiresKeepTriangles = "Dreiecke behalten";
// Synonym: Flat subdivision
topology.multiresLinear = "Linear Subdivision";
topology.multiresLinear.help = "";
// Create a new object by recomputing a new topology, by using voxels (see Glossary)
topology.voxel = "Voxel Remeshing";
topology.voxel.help = "Remeshing durch Abtasten des Meshes auf einem Raster.

If the object is not closed (watertight), an hole-filling algorithm will be applied first.

Die Layer werden nach dem Remeshing neu projiziert, aber die Qualität verschlechtert sich.";
topology.voxel.resolution = "Auflösung";
topology.voxel.remesh = "Remesh";
topology.voxel.sharp = "Scharfe Kanten beibehalten";
topology.voxel.sharp.help = "Diese Option ist vor allem für einfache boolesche Operationen nützlich.

Es wird in einigen Bereichen zu Verzerrungen kommen, da die Punkte an den Kanten gefangen werden.";
topology.voxel.subLevel = "Rebuild Multires";
topology.voxel.subLevel.help = "Sie können eine Multiresolution-Hierarchie aus der Voxel-Remesher-Ausgabe wiederherstellen.

Wird schneller ausgeführt und weniger Speicher verbrauchen, besonders wenn der Voxel-Detailwert hoch ist.
Wenn jedoch der Voxel-Detailwert niedrig ist und Sie viele Multires-Level benötigen, werden Sie Details verlieren.";
// Dynamic topology (DynTopo)
topology.surface.remesh = "Remesh";
topology.surface.detail = "Detail";
topology.surface.detail.help = "Anders als bei der Voxel-Remeshing-Methode ist es bei der Surface-Remeshing-Methode nicht erforderlich, dass das Mesh geschlossen ist.

Maskierung wird unterstützt, so dass Sie Teile des Meshes mit Masken vor Topologieänderungen schützen können.

Layer werden einwandfrei aktualisiert.";
topology.surface.method = "Methode";
// Uniformisation means we can both add and remove triangles/quads
topology.surface.method.uniformisation = "Uniformisation";
// We can only add triangles/quads (synonym: Refine)
topology.surface.method.subdivision = "Subdivision";
// We can only remove triangles/quads (synonym: Simplify)
topology.surface.method.decimation = "Decimation";
topology.surface.method.help = "Das Verhalten der dynamischen Topologie:
- Uniformisation: Hinzufügen und Entfernen von Details
- Subdivision: Details hinzufügen
- Decimation: Details entfernen";
topology.surface.useMasking = "Maskierte Bereiche schützen";
topology.surface.useMasking.help = "Die Topologie in den maskierten Bereichen wird von Änderungen ausgenommen.";
topology.surface.extrapolate = "Vertex Extrapolation";
// DynTopo
topology.dynamic = "Dynamische Topologie";
topology.dynamic.activate = "Aktiviert";
topology.dynamic.activate.help = "Mit dynamischer Topologie können Sculpting-Werkzeuge das Mesh lokal in Echtzeit unterteilen oder vereinfachen, je nach aktuellem Bedarf.

Diese Funktion kann sich spürbar auf die Leistung auswirken.

Layer werden einwandfrei aktualisiert.";
topology.dynamic.method = "Detailgrad basierend auf...";
topology.dynamic.method.zoom = "Zoom";
topology.dynamic.method.radius = "Radius";
topology.dynamic.method.constant = "Konstant";
topology.dynamic.method.help = "-- Zoom
Der Detailgrad hängt davon ab, wie weit man von der Oberfläche entfernt ist.

-- Radius
Der Radius des Werkzeugs bestimmt den Grad der Detaillierung.

-- Constant
Der Detailgrad ist festgelegt, der Detailwert wird auch mit dem Voxel-Schieberegler geteilt.";
topology.dynamic.quality = "Bevorzuge...";
topology.dynamic.quality.help = "Wenn Sie sich für Qualität entscheiden, sind die 2 wichtigsten Unterschiede:
- die Verfeinerung wird vor dem Sculpting-Operator angewandt, so dass Sie beim Painting oder Sculpting sehr kleiner Details weniger interpolierende Artefakte erhalten
- die Verfeinerung (refinement) wird nicht inkrementell angewandt. Wenn Sie sehr kleine Details modellieren oder schnelle Strokes (Striche) setzen, wird die Topologie immer korrekt verfeinert.

Für eine bessere Leistung und wenn Sie diese Option verwenden möchten, sollten Sie die Option \"partial drawing\" im Einstellungsbereich aktivieren.";
topology.dynamic.quality.speed = "Geschwindigkeit";
topology.dynamic.quality.quality = "Qualität";
// Whether the pencil pressure can impact the level of detail
topology.dynamic.usePressure = "Druck auf Radius anwenden";
topology.dynamic.usePressure.help = "Verwenden Sie diese Option, wenn Sie möchten, dass sich der Stiftdruck (pen pressure) auf den Radius des Werkzeugs auswirkt und die Detailgenauigkeit beeinflusst.";
// decimate
topology.decimate.title = "Decimation";
topology.decimate.title.help = "Verringert die Anzahl der Polygone, wobei versucht wird, so viele Details wie möglich zu erhalten.

Diese Funktion kann nützlich sein, wenn Sie für den 3D-Druck exportieren möchten.
Sie sollten diese Funktion jedoch nicht verwenden, wenn Sie mit Sculpting fortfahren wollen, da sie ungleichmäßige Dreiecke erzeugen kann.

Beachten Sie, dass der maskierte Bereich nicht dezimiert wird.";
// Synonym: Simplify (Decimate reduce the number of triangles/quads while retaining details as much as possible)
topology.decimate = "Decimate";
topology.decimateTargetFaces = "Ziel Dreiecke";
topology.decimatePaintWeight = "Painting erhalten";
topology.decimatePaintWeight.help = "Ein höherer Wert wird versuchen, Painting zu erhalten.

Setzen Sie diesen Wert auf 0, wenn Painting keine Rolle spielt.";
topology.decimateUniform = "Uniform Faces";
topology.decimateUniform.help = "Ein höherer Wert führt zur Ausgabe von Dreiecken mit ähnlicher Größe.";
// topology.decimatePreserveBorders "Preserve borders"
// topology.decimatePreserveBorders.help "Do not decimate the border of the mesh.

// Unwrapping means compute UV (texture coordinates), it allows the object to receive on texture (wrap the texturing on the object)
topology.uv.title = "UV Auto-Unwrap";
topology.uvAtlas = "Unwrap Atlas";
topology.uvAtlas.warning = "Kann sehr langsam sein, Ziel: <100k Vertices!";
topology.uvBFF = "Unwrap BFF";
topology.uvBFF.warning = "Es kann zu Überschneidungen kommen, wenn das Mesh Handles aufweist!";
topology.uvBFFCones = "Kegel-Anzahl";
topology.uvBFFCones.help = "Ein höherer Wert verringert die Verzerrung bei komplexen Objekten.

Ein höherer Wert bedeutet aber auch eine längere Berechnungszeit.";
topology.uvDelete = "UVs löschen";

// Transfer the vertex painting in the texture
topology.bake = "";
topology.bake.help = "";
topology.bakeResolution = "";

// privacy policy
privacyPolicy.title = "";
privacyPolicy.reject = "";
privacyPolicy = "";

// version trial
version.buyWeb = "Die Web-Version ist nur eine Demo";
version.buyFull = "Upgrade auf Vollversion";
version.restorePurchase = "Kauf wiederherstellen";

version.trialHistory = "Trial version: Nur 4 UnDo/Redo möglich";
version.trialLayer = "Trial version: Nur 1 Layer pro Mesh";
version.trialOneProject = "Trial version: Nur 1 aktives Projekt";
version.trialNoImport = "Trial version: Kein Import";
version.trialNoExport = "Trial version: Kein Export";

version.fullFeatures = "- UnDo/ReDo unbegrenzt
- Unbegrenzte Layer
- Speichern  & Laden
- Export & Import";
